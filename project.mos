model ModelName
  options noimplicit
  uses "mmxprs"

  parameters
    n = 4                               ! numero di jobs
    m = 8                               ! numero di tools
    B = 3                               ! max numero tool su macchina
  end-parameters

  forward procedure printParams
  forward procedure printResults

  declarations

    J = 1..n                            ! insieme dei Jobs
    J0 = 0..n                           ! insieme dei Jobs U {0}

    T = 0..m                            ! insieme dei Tools
    T_j : array(J0) of set of integer   ! array di insiemi di Tools necessari per il Job j

    Tc_m : array(T) of integer          ! costi di montaggio tool t
    Tc_s : array(T) of integer          ! costi di smontaggio tool t

    x_ij : array(J0, J0) of mpvar       ! 1 se job 'j' segue immediatamente job 'i' - 0 altrimenti
    z_ij_t : array(J0, J0, T) of mpvar  ! 1 se tool 't' viene aggiunto nel passaggio i->j [TODO: controllare grandeza T]
    y_ij_t : array(J0, J0, T) of mpvar  ! 1 se tool 't' viene lasciato nel passaggio i->j [TODO: controllare grandeza T]

    u : array(J0) of mpvar              ! array contenete ordinamento posizionale Jobs

    mintime : linctr

    Job_seq : array(J0) of integer      ! aux var per print solution
    cur_job : integer                   ! aux var per print solution
    seq : integer                       ! aux var per print solution

  end-declarations

  !************** assignement *************! TODO: external file assignment

  !Tc_m :: [3, 4, 2, 5, 7, 3, 2, 6]
  !Tc_s :: [6, 4, 2, 8, 2, 4, 5, 3]
  Tc_m :: [1,1,1,1,1,1,1,1]
  Tc_s :: [1,1,1,1,1,1,1,1]

  (!
  T_j(0) := {}
  T_j(1) := {1,4,8,9}
  T_j(2) := {1,3,5}
  T_j(3) := {2,6,7,8}
  T_j(4) := {1,5,7,9}
  T_j(5) := {3,5,8}
  T_j(6) := {1,2,4}
  T_j(7) := {1}
  T_j(8) := {6}
  T_j(9) := {3}
  T_j(10) := {5,7}
  !)
  
  T_j(0) := {}
  T_j(1) := {1,2}
  T_j(2) := {3,4,5}
  T_j(3) := {1,2}
  T_j(4) := {3,4,6}
  
  !T_j :: [{2, 4, 3, 5} ,{4, 3, 1}, {1, 2, 3, 7}, {3}]

  printParams

  !************** constraints *************!

  !mintime := sum(i,j in J0 | i<>j)(sum(t in T_j(j))(z_ij_t(i,j,t)*(Tc_m(t)+Tc_s(t))))
  mintime := sum(i,j in J0 | i<>j)sum(t in T_j(j))z_ij_t(i,j,t)

  ! vincoli su variabili binarie
  forall(i,j in J0 | i<>j)
    x_ij(i,j) is_binary

  forall(i,j in J0 | i<>j, t in T) do
    z_ij_t(i,j,t) is_binary
    y_ij_t(i,j,t) is_binary
  end-do

  ! Vincoli di flusso: garantiscono che ogni nodo venga visitato esattamente una volta
  forall(i in J0)
    sum(j in J0-{i})x_ij(i,j) = 1

  forall(j in J0)
    sum(i in J0-{j})x_ij(i,j) = 1

  ! Vincolo di eliminazione dei sottotour: evita la formazione di sottotour + vincolo di dominio
  u(0) = 0

  forall(i,j in J | i<>j)
    u(i) - u(j) + n*x_ij(i,j) <= n-1

  forall(i in J) do
    u(i) >= 1
    u(i) <= n
  end-do

  !TODO: etichettare 3e
  forall(j in J0, t in T_j(j))
    sum(i in J0-{j})(y_ij_t(i,j,t) + z_ij_t(i,j,t)) = 1

  !TODO: etichettare 3f
  (!
  forall(i,j in J0 | i<>j, t in T | t not in T_j(i) and t in T_j(j))
    y_ij_t(i,j,t) + z_ij_t(i,j,t) <= x_ij(i,j)
  !)
  forall(i,j in J0 | i<>j, t in T-{0} | t not in T_j(i) and t in T_j(j))
    y_ij_t(i,j,t) + z_ij_t(i,j,t) = x_ij(i,j)
    
  forall(i,j in J0 | i<>j, t in T-{0} | t in T_j(i) and t in T_j(j))
    y_ij_t(i,j,t) = x_ij(i,j)
  
  forall(i,j in J0 | i<>j, t in T | t not in T_j(j))
    y_ij_t(i,j,t) <= x_ij(i,j)
  
  
  !TODO: etichettare 3g
  forall(i,j in J0 | i<>j)
    sum(t in T)(y_ij_t(i,j,t) + z_ij_t(i,j,t)) <= B*x_ij(i,j)

  !TODO etichettare 3h
  forall(i in J0, t in T-{0})
    sum(k in J0-{i})(y_ij_t(k,i,t) + z_ij_t(k,i,t)) >= sum(j in J0-{i})y_ij_t(i,j,t)

  !TODO etichettare 3i
  forall(i,j in J0 | i<>j, t in T_j(i) | t in T_j(j))
    y_ij_t(i,j,t) >= x_ij(i,j)

  !TODO etichettare 3j
  forall(i,j in J0 | i<>j, t in T-{0} | t not in T_j(j))
    z_ij_t(i,j,t) = 0

  !TODO etichettare 3k
  forall(j in J, t in T-{0})
    y_ij_t(0,j,t) = 0
    
  minimize(mintime)

 printResults

  !************** procedures *************!

  procedure printParams
    write("\n")
    write("\n- Insieme dei Jobs 'J': ")
      forall(j in J)
        write(j, " ")

    write("\n- Insieme dei Jobs 'J0': ")
      forall(j in J0)
        write(j, " ")

    write("\n- Insieme dei Tools per:")
    forall(j in J0)
      write("\n\tJob ", j, ": ", T_j(j))

    write("\n- Costi di montaggio:")
    forall(t in T)
      write("\n\tTool ", t, ": ", Tc_m(t))

    write("\n- Costi di smontaggio:")
    forall(t in T)
      write("\n\tTool ", t, ": ", Tc_s(t))
  end-procedure


  procedure printResults
    write("\n")

    ! Print matrice x_ij
    (!
    forall(i in J0) do
      write("\n")
      forall(j in J0)
        write(getsol(x_ij(i,j)))
    end-do
    !)
    ! Print sequenza Job sotto forma di vettore
    cur_job := 0
    seq := 0
    Job_seq(seq) := cur_job
    seq := 1
    forall(i in 0..n-1) do
      forall(j in 0..n) do
        if getsol(x_ij(cur_job,j)) > 0 then
          cur_job := j
          Job_seq(seq) := j
          seq := seq+1
          break
        end-if
      end-do

    end-do
    write("\n - Job sequence:\n\t")
    forall(i in J0) do
      write(Job_seq(i))
      if i<n then
        write("->")
      end-if
    end-do

    write("\n- Tool sequence:\n")
    forall(i in J0) do
      write("\t")
      write("J",Job_seq(i),": ",T_j(Job_seq(i)))
      write("\n")
    end-do
    ! Print mintime solution
    write("- mintime: ",getobjval)
  end-procedure


end-model
